# !! THIS FILE IS AUTOMATICALLY GENERATED.
# DO NOT EDIT. 
# SEE simplificationtermhelper.py

from typing import Callable, List, Tuple
import numpy as np

def ClCHm_hopping(sw1_up: bool, sw1_index: int, sw1_occupation: int, sw1_occupation_os: int, sw2_up: bool, sw2_index: int, sw2_occupation: int, sw2_occupation_os: int, lam: Callable[[int, int], np.complex128], sw1_neighbors_index_occupation_tuples: List[Tuple[int,int,int]], sw2_neighbors_index_occupation_tuples: List[Tuple[int,int,int]]) -> np.complex128:
    res:np.complex128 = np.complex128(0)
    if sw1_up and sw2_up:
        # UP<->UP
        pass
        res += lam(sw2_index,sw1_index) * (sw1_occupation-sw2_occupation)
        res += lam(sw1_index,sw2_index) * (sw2_occupation-sw1_occupation)
        # sum(i,l)
        for (l, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(l,sw1_index) * ((nb_occupation-1)*(sw2_occupation-sw1_occupation))
        # sum(j,l)
        for (l, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(l,sw2_index) * ((nb_occupation-1)*(sw1_occupation-sw2_occupation))
        # sum(j,m)
        for (m, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(sw2_index,m) * ((sw1_occupation-sw2_occupation)*nb_occupation)
        # sum(i,m)
        for (m, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(sw1_index,m) * ((sw2_occupation-sw1_occupation)*nb_occupation)
    if sw1_up and not sw2_up:
        # UP<->DOWN
        pass
        res += lam(sw2_index,sw1_index) * ((sw2_occupation-1)*(sw2_occupation_os-sw1_occupation))
        res += lam(sw1_index,sw2_index) * ((sw2_occupation_os-sw1_occupation)*sw2_occupation)
        # sum(i,l)
        for (l, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(l,sw1_index) * ((nb_occupation-1)*(sw2_occupation_os-sw1_occupation))
        # sum(i,m)
        for (m, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(sw1_index,m) * ((sw2_occupation_os-sw1_occupation)*nb_occupation)
    if not sw1_up and sw2_up:
        # DOWN<->UP
        pass
        res += lam(sw2_index,sw1_index) * ((sw1_occupation_os-sw2_occupation)*sw1_occupation)
        res += lam(sw1_index,sw2_index) * ((sw1_occupation-1)*(sw1_occupation_os-sw2_occupation))
        # sum(j,l)
        for (l, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(l,sw2_index) * ((nb_occupation-1)*(sw1_occupation_os-sw2_occupation))
        # sum(j,m)
        for (m, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(sw2_index,m) * ((sw1_occupation_os-sw2_occupation)*nb_occupation)
    if not sw1_up and not sw2_up:
        # DOWN<->DOWN
        pass
    return res


def DlDHm_hopping(sw1_up: bool, sw1_index: int, sw1_occupation: int, sw1_occupation_os: int, sw2_up: bool, sw2_index: int, sw2_occupation: int, sw2_occupation_os: int, lam: Callable[[int, int], np.complex128], sw1_neighbors_index_occupation_tuples: List[Tuple[int,int,int]], sw2_neighbors_index_occupation_tuples: List[Tuple[int,int,int]]) -> np.complex128:
    res:np.complex128 = np.complex128(0)
    if sw1_up and sw2_up:
        # UP<->UP
        pass
    if sw1_up and not sw2_up:
        # UP<->DOWN
        pass
        res += lam(sw2_index,sw1_index) * ((sw1_occupation-sw2_occupation_os)*sw1_occupation_os)
        res += lam(sw1_index,sw2_index) * ((sw1_occupation_os-1)*(sw1_occupation-sw2_occupation_os))
        # sum(j,l)
        for (l, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(l,sw2_index) * ((nb_occupation_os-1)*(sw1_occupation-sw2_occupation_os))
        # sum(j,m)
        for (m, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(sw2_index,m) * ((sw1_occupation-sw2_occupation_os)*nb_occupation_os)
    if not sw1_up and sw2_up:
        # DOWN<->UP
        pass
        res += lam(sw2_index,sw1_index) * ((sw2_occupation_os-1)*(sw2_occupation-sw1_occupation_os))
        res += lam(sw1_index,sw2_index) * ((sw2_occupation-sw1_occupation_os)*sw2_occupation_os)
        # sum(i,l)
        for (l, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(l,sw1_index) * ((nb_occupation_os-1)*(sw2_occupation-sw1_occupation_os))
        # sum(i,m)
        for (m, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(sw1_index,m) * ((sw2_occupation-sw1_occupation_os)*nb_occupation_os)
    if not sw1_up and not sw2_up:
        # DOWN<->DOWN
        pass
        res += lam(sw2_index,sw1_index) * (sw1_occupation_os-sw2_occupation_os)
        res += lam(sw1_index,sw2_index) * (sw2_occupation_os-sw1_occupation_os)
        # sum(i,l)
        for (l, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(l,sw1_index) * ((nb_occupation_os-1)*(sw2_occupation_os-sw1_occupation_os))
        # sum(j,l)
        for (l, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(l,sw2_index) * ((nb_occupation_os-1)*(sw1_occupation_os-sw2_occupation_os))
        # sum(j,m)
        for (m, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(sw2_index,m) * ((sw1_occupation_os-sw2_occupation_os)*nb_occupation_os)
        # sum(i,m)
        for (m, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(sw1_index,m) * ((sw2_occupation_os-sw1_occupation_os)*nb_occupation_os)
    return res


def ClCmCHlCHmDlDHm_hopping(sw1_up: bool, sw1_index: int, sw1_occupation: int, sw1_occupation_os: int, sw2_up: bool, sw2_index: int, sw2_occupation: int, sw2_occupation_os: int, lam: Callable[[int, int], np.complex128], sw1_neighbors_index_occupation_tuples: List[Tuple[int,int,int]], sw2_neighbors_index_occupation_tuples: List[Tuple[int,int,int]]) -> np.complex128:
    res:np.complex128 = np.complex128(0)
    if sw1_up and sw2_up:
        # UP<->UP
        pass
        # sum(i,l)
        for (l, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(l,sw1_index) * ((nb_occupation-1)*(nb_occupation_os-1)*(sw2_occupation-sw1_occupation)*sw1_occupation_os)
        # sum(j,l)
        for (l, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(l,sw2_index) * ((nb_occupation-1)*(nb_occupation_os-1)*(sw1_occupation-sw2_occupation)*sw2_occupation_os)
        # sum(j,m)
        for (m, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(sw2_index,m) * ((nb_occupation-1)*(sw2_occupation_os-1)*(sw1_occupation-sw2_occupation)*nb_occupation_os)
        # sum(i,m)
        for (m, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(sw1_index,m) * ((nb_occupation-1)*(sw1_occupation_os-1)*(sw2_occupation-sw1_occupation)*nb_occupation_os)
    if sw1_up and not sw2_up:
        # UP<->DOWN
        pass
        res += lam(sw1_index,sw2_index) * ((sw2_occupation-1)*(sw1_occupation_os-1)*(((sw2_occupation_os-1)*sw1_occupation)+-((sw1_occupation-1)*sw2_occupation_os)))
        # sum(i,l)
        for (l, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(l,sw1_index) * ((nb_occupation-1)*(nb_occupation_os-1)*(sw2_occupation_os-sw1_occupation)*sw1_occupation_os)
        # sum(j,l)
        for (l, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(l,sw2_index) * ((sw2_occupation-1)*(nb_occupation-1)*(nb_occupation_os-1)*(sw1_occupation-sw2_occupation_os))
        # sum(j,m)
        for (m, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(sw2_index,m) * ((sw2_occupation-1)*(nb_occupation-1)*(sw1_occupation-sw2_occupation_os)*nb_occupation_os)
        # sum(i,m)
        for (m, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(sw1_index,m) * ((nb_occupation-1)*(sw1_occupation_os-1)*(sw2_occupation_os-sw1_occupation)*nb_occupation_os)
    if not sw1_up and sw2_up:
        # DOWN<->UP
        pass
        res += lam(sw2_index,sw1_index) * ((sw1_occupation-1)*(sw2_occupation_os-1)*(((sw1_occupation_os-1)*sw2_occupation)+-((sw2_occupation-1)*sw1_occupation_os)))
        # sum(i,l)
        for (l, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(l,sw1_index) * ((sw1_occupation-1)*(nb_occupation-1)*(nb_occupation_os-1)*(sw2_occupation-sw1_occupation_os))
        # sum(j,l)
        for (l, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(l,sw2_index) * ((nb_occupation-1)*(nb_occupation_os-1)*(sw1_occupation_os-sw2_occupation)*sw2_occupation_os)
        # sum(j,m)
        for (m, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(sw2_index,m) * ((nb_occupation-1)*(sw2_occupation_os-1)*(sw1_occupation_os-sw2_occupation)*nb_occupation_os)
        # sum(i,m)
        for (m, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(sw1_index,m) * ((sw1_occupation-1)*(nb_occupation-1)*(sw2_occupation-sw1_occupation_os)*nb_occupation_os)
    if not sw1_up and not sw2_up:
        # DOWN<->DOWN
        pass
        res += lam(sw2_index,sw1_index) * ((sw1_occupation-1)*(sw2_occupation-1)*(((sw1_occupation_os-1)*sw2_occupation_os)+-((sw2_occupation_os-1)*sw1_occupation_os)))
        res += lam(sw1_index,sw2_index) * ((sw1_occupation-1)*(sw2_occupation-1)*(((sw2_occupation_os-1)*sw1_occupation_os)+-((sw1_occupation_os-1)*sw2_occupation_os)))
        # sum(i,l)
        for (l, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(l,sw1_index) * ((sw1_occupation-1)*(nb_occupation-1)*(nb_occupation_os-1)*(sw2_occupation_os-sw1_occupation_os))
        # sum(j,l)
        for (l, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(l,sw2_index) * ((sw2_occupation-1)*(nb_occupation-1)*(nb_occupation_os-1)*(sw1_occupation_os-sw2_occupation_os))
        # sum(j,m)
        for (m, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(sw2_index,m) * ((sw2_occupation-1)*(nb_occupation-1)*(sw1_occupation_os-sw2_occupation_os)*nb_occupation_os)
        # sum(i,m)
        for (m, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(sw1_index,m) * ((sw1_occupation-1)*(nb_occupation-1)*(sw2_occupation_os-sw1_occupation_os)*nb_occupation_os)
    return res


def ClCHmDlDmDHlDHm_hopping(sw1_up: bool, sw1_index: int, sw1_occupation: int, sw1_occupation_os: int, sw2_up: bool, sw2_index: int, sw2_occupation: int, sw2_occupation_os: int, lam: Callable[[int, int], np.complex128], sw1_neighbors_index_occupation_tuples: List[Tuple[int,int,int]], sw2_neighbors_index_occupation_tuples: List[Tuple[int,int,int]]) -> np.complex128:
    res:np.complex128 = np.complex128(0)
    if sw1_up and sw2_up:
        # UP<->UP
        pass
        res += lam(sw2_index,sw1_index) * ((sw1_occupation_os-1)*(sw2_occupation_os-1)*(((sw1_occupation-1)*sw2_occupation)+-((sw2_occupation-1)*sw1_occupation)))
        res += lam(sw1_index,sw2_index) * ((sw1_occupation_os-1)*(sw2_occupation_os-1)*(((sw2_occupation-1)*sw1_occupation)+-((sw1_occupation-1)*sw2_occupation)))
        # sum(i,l)
        for (l, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(l,sw1_index) * ((nb_occupation-1)*(sw1_occupation_os-1)*(nb_occupation_os-1)*(sw2_occupation-sw1_occupation))
        # sum(j,l)
        for (l, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(l,sw2_index) * ((nb_occupation-1)*(sw2_occupation_os-1)*(nb_occupation_os-1)*(sw1_occupation-sw2_occupation))
        # sum(j,m)
        for (m, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(sw2_index,m) * ((sw2_occupation_os-1)*(nb_occupation_os-1)*(sw1_occupation-sw2_occupation)*nb_occupation)
        # sum(i,m)
        for (m, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(sw1_index,m) * ((sw1_occupation_os-1)*(nb_occupation_os-1)*(sw2_occupation-sw1_occupation)*nb_occupation)
    if sw1_up and not sw2_up:
        # UP<->DOWN
        pass
        res += lam(sw2_index,sw1_index) * ((sw2_occupation-1)*(sw1_occupation_os-1)*(((sw1_occupation-1)*sw2_occupation_os)+-((sw2_occupation_os-1)*sw1_occupation)))
        # sum(i,l)
        for (l, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(l,sw1_index) * ((nb_occupation-1)*(sw1_occupation_os-1)*(nb_occupation_os-1)*(sw2_occupation_os-sw1_occupation))
        # sum(j,l)
        for (l, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(l,sw2_index) * ((nb_occupation-1)*(nb_occupation_os-1)*(sw1_occupation-sw2_occupation_os)*sw2_occupation)
        # sum(j,m)
        for (m, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(sw2_index,m) * ((sw2_occupation-1)*(nb_occupation_os-1)*(sw1_occupation-sw2_occupation_os)*nb_occupation)
        # sum(i,m)
        for (m, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(sw1_index,m) * ((sw1_occupation_os-1)*(nb_occupation_os-1)*(sw2_occupation_os-sw1_occupation)*nb_occupation)
    if not sw1_up and sw2_up:
        # DOWN<->UP
        pass
        res += lam(sw1_index,sw2_index) * ((sw1_occupation-1)*(sw2_occupation_os-1)*(((sw2_occupation-1)*sw1_occupation_os)+-((sw1_occupation_os-1)*sw2_occupation)))
        # sum(i,l)
        for (l, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(l,sw1_index) * ((nb_occupation-1)*(nb_occupation_os-1)*(sw2_occupation-sw1_occupation_os)*sw1_occupation)
        # sum(j,l)
        for (l, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(l,sw2_index) * ((nb_occupation-1)*(sw2_occupation_os-1)*(nb_occupation_os-1)*(sw1_occupation_os-sw2_occupation))
        # sum(j,m)
        for (m, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(sw2_index,m) * ((sw2_occupation_os-1)*(nb_occupation_os-1)*(sw1_occupation_os-sw2_occupation)*nb_occupation)
        # sum(i,m)
        for (m, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(sw1_index,m) * ((sw1_occupation-1)*(nb_occupation_os-1)*(sw2_occupation-sw1_occupation_os)*nb_occupation)
    if not sw1_up and not sw2_up:
        # DOWN<->DOWN
        pass
        # sum(i,l)
        for (l, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(l,sw1_index) * ((nb_occupation-1)*(nb_occupation_os-1)*(sw2_occupation_os-sw1_occupation_os)*sw1_occupation)
        # sum(j,l)
        for (l, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(l,sw2_index) * ((nb_occupation-1)*(nb_occupation_os-1)*(sw1_occupation_os-sw2_occupation_os)*sw2_occupation)
        # sum(j,m)
        for (m, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(sw2_index,m) * ((sw2_occupation-1)*(nb_occupation_os-1)*(sw1_occupation_os-sw2_occupation_os)*nb_occupation)
        # sum(i,m)
        for (m, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(sw1_index,m) * ((sw1_occupation-1)*(nb_occupation_os-1)*(sw2_occupation_os-sw1_occupation_os)*nb_occupation)
    return res


def ClCHlDlDHm_hopping(sw1_up: bool, sw1_index: int, sw1_occupation: int, sw1_occupation_os: int, sw2_up: bool, sw2_index: int, sw2_occupation: int, sw2_occupation_os: int, lam: Callable[[int, int], np.complex128], sw1_neighbors_index_occupation_tuples: List[Tuple[int,int,int]], sw2_neighbors_index_occupation_tuples: List[Tuple[int,int,int]]) -> np.complex128:
    res:np.complex128 = np.complex128(0)
    if sw1_up and sw2_up:
        # UP<->UP
        pass
        res += lam(sw2_index,sw1_index) * ((sw2_occupation_os-1)*(sw2_occupation-sw1_occupation)*sw1_occupation_os)
        res += lam(sw1_index,sw2_index) * ((sw1_occupation_os-1)*(sw1_occupation-sw2_occupation)*sw2_occupation_os)
        # sum(j,m)
        for (m, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(sw2_index,m) * ((sw2_occupation_os-1)*(sw2_occupation-sw1_occupation)*nb_occupation_os)
        # sum(i,m)
        for (m, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(sw1_index,m) * ((sw1_occupation_os-1)*(sw1_occupation-sw2_occupation)*nb_occupation_os)
    if sw1_up and not sw2_up:
        # UP<->DOWN
        pass
        res += lam(sw2_index,sw1_index) * ((sw2_occupation-1)*(sw2_occupation_os-sw1_occupation)*sw1_occupation_os)
        res += lam(sw1_index,sw2_index) * ((sw1_occupation*sw1_occupation_os)+sw2_occupation_os-sw1_occupation-(sw1_occupation_os*sw2_occupation_os))
        # sum(j,l)
        for (l, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(l,sw2_index) * ((nb_occupation-1)*(nb_occupation_os-1)*(sw2_occupation_os-sw1_occupation))
        # sum(j,m)
        for (m, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(sw2_index,m) * ((sw2_occupation-1)*(sw2_occupation_os-sw1_occupation)*nb_occupation_os)
        # sum(i,m)
        for (m, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(sw1_index,m) * ((sw1_occupation_os-1)*(sw1_occupation-sw2_occupation_os)*nb_occupation_os)
    if not sw1_up and sw2_up:
        # DOWN<->UP
        pass
        res += lam(sw2_index,sw1_index) * ((sw2_occupation*sw2_occupation_os)+sw1_occupation_os-sw2_occupation-(sw1_occupation_os*sw2_occupation_os))
        res += lam(sw1_index,sw2_index) * ((sw1_occupation-1)*(sw1_occupation_os-sw2_occupation)*sw2_occupation_os)
        # sum(i,l)
        for (l, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(l,sw1_index) * ((nb_occupation-1)*(nb_occupation_os-1)*(sw1_occupation_os-sw2_occupation))
        # sum(j,m)
        for (m, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(sw2_index,m) * ((sw2_occupation_os-1)*(sw2_occupation-sw1_occupation_os)*nb_occupation_os)
        # sum(i,m)
        for (m, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(sw1_index,m) * ((sw1_occupation-1)*(sw1_occupation_os-sw2_occupation)*nb_occupation_os)
    if not sw1_up and not sw2_up:
        # DOWN<->DOWN
        pass
        res += lam(sw2_index,sw1_index) * ((sw2_occupation*sw2_occupation_os)+sw1_occupation_os-sw2_occupation_os-(sw2_occupation*sw1_occupation_os))
        res += lam(sw1_index,sw2_index) * ((sw1_occupation*sw1_occupation_os)+sw2_occupation_os-sw1_occupation_os-(sw1_occupation*sw2_occupation_os))
        # sum(i,l)
        for (l, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(l,sw1_index) * ((nb_occupation-1)*(nb_occupation_os-1)*(sw1_occupation_os-sw2_occupation_os))
        # sum(j,l)
        for (l, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(l,sw2_index) * ((nb_occupation-1)*(nb_occupation_os-1)*(sw2_occupation_os-sw1_occupation_os))
        # sum(j,m)
        for (m, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(sw2_index,m) * ((sw2_occupation-1)*(sw2_occupation_os-sw1_occupation_os)*nb_occupation_os)
        # sum(i,m)
        for (m, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(sw1_index,m) * ((sw1_occupation-1)*(sw1_occupation_os-sw2_occupation_os)*nb_occupation_os)
    return res


def CmCHmDlDHm_hopping(sw1_up: bool, sw1_index: int, sw1_occupation: int, sw1_occupation_os: int, sw2_up: bool, sw2_index: int, sw2_occupation: int, sw2_occupation_os: int, lam: Callable[[int, int], np.complex128], sw1_neighbors_index_occupation_tuples: List[Tuple[int,int,int]], sw2_neighbors_index_occupation_tuples: List[Tuple[int,int,int]]) -> np.complex128:
    res:np.complex128 = np.complex128(0)
    if sw1_up and sw2_up:
        # UP<->UP
        pass
        res += lam(sw2_index,sw1_index) * ((sw2_occupation_os-1)*(sw1_occupation-sw2_occupation)*sw1_occupation_os)
        res += lam(sw1_index,sw2_index) * ((sw1_occupation_os-1)*(sw2_occupation-sw1_occupation)*sw2_occupation_os)
        # sum(i,l)
        for (l, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(l,sw1_index) * ((nb_occupation_os-1)*(sw1_occupation-sw2_occupation)*sw1_occupation_os)
        # sum(j,l)
        for (l, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(l,sw2_index) * ((nb_occupation_os-1)*(sw2_occupation-sw1_occupation)*sw2_occupation_os)
    if sw1_up and not sw2_up:
        # UP<->DOWN
        pass
        res += lam(sw1_index,sw2_index) * ((sw2_occupation-1)*(sw1_occupation_os-1)*(sw2_occupation_os-sw1_occupation))
        # sum(i,l)
        for (l, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(l,sw1_index) * ((nb_occupation_os-1)*(sw1_occupation-sw2_occupation_os)*sw1_occupation_os)
        # sum(j,l)
        for (l, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(l,sw2_index) * ((sw2_occupation-1)*(nb_occupation_os-1)*(sw2_occupation_os-sw1_occupation))
        # sum(j,m)
        for (m, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(sw2_index,m) * ((nb_occupation-1)*(sw2_occupation_os-sw1_occupation)*nb_occupation_os)
    if not sw1_up and sw2_up:
        # DOWN<->UP
        pass
        res += lam(sw2_index,sw1_index) * ((sw1_occupation-1)*(sw2_occupation_os-1)*(sw1_occupation_os-sw2_occupation))
        # sum(i,l)
        for (l, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(l,sw1_index) * ((sw1_occupation-1)*(nb_occupation_os-1)*(sw1_occupation_os-sw2_occupation))
        # sum(j,l)
        for (l, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(l,sw2_index) * ((nb_occupation_os-1)*(sw2_occupation-sw1_occupation_os)*sw2_occupation_os)
        # sum(i,m)
        for (m, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(sw1_index,m) * ((nb_occupation-1)*(sw1_occupation_os-sw2_occupation)*nb_occupation_os)
    if not sw1_up and not sw2_up:
        # DOWN<->DOWN
        pass
        res += lam(sw2_index,sw1_index) * ((sw1_occupation*sw2_occupation_os)+sw1_occupation_os-sw2_occupation_os-(sw1_occupation*sw1_occupation_os))
        res += lam(sw1_index,sw2_index) * ((sw2_occupation*sw1_occupation_os)+sw2_occupation_os-sw1_occupation_os-(sw2_occupation*sw2_occupation_os))
        # sum(i,l)
        for (l, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(l,sw1_index) * ((sw1_occupation-1)*(nb_occupation_os-1)*(sw1_occupation_os-sw2_occupation_os))
        # sum(j,l)
        for (l, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(l,sw2_index) * ((sw2_occupation-1)*(nb_occupation_os-1)*(sw2_occupation_os-sw1_occupation_os))
        # sum(j,m)
        for (m, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(sw2_index,m) * ((nb_occupation-1)*(sw2_occupation_os-sw1_occupation_os)*nb_occupation_os)
        # sum(i,m)
        for (m, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(sw1_index,m) * ((nb_occupation-1)*(sw1_occupation_os-sw2_occupation_os)*nb_occupation_os)
    return res


def ClCHmDlDHl_hopping(sw1_up: bool, sw1_index: int, sw1_occupation: int, sw1_occupation_os: int, sw2_up: bool, sw2_index: int, sw2_occupation: int, sw2_occupation_os: int, lam: Callable[[int, int], np.complex128], sw1_neighbors_index_occupation_tuples: List[Tuple[int,int,int]], sw2_neighbors_index_occupation_tuples: List[Tuple[int,int,int]]) -> np.complex128:
    res:np.complex128 = np.complex128(0)
    if sw1_up and sw2_up:
        # UP<->UP
        pass
        res += lam(sw2_index,sw1_index) * ((sw2_occupation*sw2_occupation_os)+sw1_occupation-sw2_occupation-(sw1_occupation*sw2_occupation_os))
        res += lam(sw1_index,sw2_index) * ((sw1_occupation*sw1_occupation_os)+sw2_occupation-sw1_occupation-(sw2_occupation*sw1_occupation_os))
        # sum(i,l)
        for (l, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(l,sw1_index) * ((nb_occupation-1)*(nb_occupation_os-1)*(sw1_occupation-sw2_occupation))
        # sum(j,l)
        for (l, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(l,sw2_index) * ((nb_occupation-1)*(nb_occupation_os-1)*(sw2_occupation-sw1_occupation))
        # sum(j,m)
        for (m, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(sw2_index,m) * ((sw2_occupation_os-1)*(sw2_occupation-sw1_occupation)*nb_occupation)
        # sum(i,m)
        for (m, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(sw1_index,m) * ((sw1_occupation_os-1)*(sw1_occupation-sw2_occupation)*nb_occupation)
    if sw1_up and not sw2_up:
        # UP<->DOWN
        pass
        res += lam(sw2_index,sw1_index) * ((sw2_occupation*sw2_occupation_os)+sw1_occupation-sw2_occupation_os-(sw1_occupation*sw2_occupation))
        res += lam(sw1_index,sw2_index) * ((sw1_occupation_os-1)*(sw1_occupation-sw2_occupation_os)*sw2_occupation)
        # sum(i,l)
        for (l, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(l,sw1_index) * ((nb_occupation-1)*(nb_occupation_os-1)*(sw1_occupation-sw2_occupation_os))
        # sum(j,m)
        for (m, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(sw2_index,m) * ((sw2_occupation-1)*(sw2_occupation_os-sw1_occupation)*nb_occupation)
        # sum(i,m)
        for (m, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(sw1_index,m) * ((sw1_occupation_os-1)*(sw1_occupation-sw2_occupation_os)*nb_occupation)
    if not sw1_up and sw2_up:
        # DOWN<->UP
        pass
        res += lam(sw2_index,sw1_index) * ((sw2_occupation_os-1)*(sw2_occupation-sw1_occupation_os)*sw1_occupation)
        res += lam(sw1_index,sw2_index) * ((sw1_occupation*sw1_occupation_os)+sw2_occupation-sw1_occupation_os-(sw1_occupation*sw2_occupation))
        # sum(j,l)
        for (l, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(l,sw2_index) * ((nb_occupation-1)*(nb_occupation_os-1)*(sw2_occupation-sw1_occupation_os))
        # sum(j,m)
        for (m, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(sw2_index,m) * ((sw2_occupation_os-1)*(sw2_occupation-sw1_occupation_os)*nb_occupation)
        # sum(i,m)
        for (m, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(sw1_index,m) * ((sw1_occupation-1)*(sw1_occupation_os-sw2_occupation)*nb_occupation)
    if not sw1_up and not sw2_up:
        # DOWN<->DOWN
        pass
        res += lam(sw2_index,sw1_index) * ((sw2_occupation-1)*(sw2_occupation_os-sw1_occupation_os)*sw1_occupation)
        res += lam(sw1_index,sw2_index) * ((sw1_occupation-1)*(sw1_occupation_os-sw2_occupation_os)*sw2_occupation)
        # sum(j,m)
        for (m, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(sw2_index,m) * ((sw2_occupation-1)*(sw2_occupation_os-sw1_occupation_os)*nb_occupation)
        # sum(i,m)
        for (m, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(sw1_index,m) * ((sw1_occupation-1)*(sw1_occupation_os-sw2_occupation_os)*nb_occupation)
    return res


def ClCHmDmDHm_hopping(sw1_up: bool, sw1_index: int, sw1_occupation: int, sw1_occupation_os: int, sw2_up: bool, sw2_index: int, sw2_occupation: int, sw2_occupation_os: int, lam: Callable[[int, int], np.complex128], sw1_neighbors_index_occupation_tuples: List[Tuple[int,int,int]], sw2_neighbors_index_occupation_tuples: List[Tuple[int,int,int]]) -> np.complex128:
    res:np.complex128 = np.complex128(0)
    if sw1_up and sw2_up:
        # UP<->UP
        pass
        res += lam(sw2_index,sw1_index) * ((sw2_occupation*sw1_occupation_os)+sw1_occupation-sw2_occupation-(sw1_occupation*sw1_occupation_os))
        res += lam(sw1_index,sw2_index) * ((sw1_occupation*sw2_occupation_os)+sw2_occupation-sw1_occupation-(sw2_occupation*sw2_occupation_os))
        # sum(i,l)
        for (l, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(l,sw1_index) * ((nb_occupation-1)*(sw1_occupation_os-1)*(sw1_occupation-sw2_occupation))
        # sum(j,l)
        for (l, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(l,sw2_index) * ((nb_occupation-1)*(sw2_occupation_os-1)*(sw2_occupation-sw1_occupation))
        # sum(j,m)
        for (m, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(sw2_index,m) * ((nb_occupation_os-1)*(sw2_occupation-sw1_occupation)*nb_occupation)
        # sum(i,m)
        for (m, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(sw1_index,m) * ((nb_occupation_os-1)*(sw1_occupation-sw2_occupation)*nb_occupation)
    if sw1_up and not sw2_up:
        # UP<->DOWN
        pass
        res += lam(sw2_index,sw1_index) * ((sw2_occupation-1)*(sw1_occupation_os-1)*(sw1_occupation-sw2_occupation_os))
        # sum(i,l)
        for (l, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(l,sw1_index) * ((nb_occupation-1)*(sw1_occupation_os-1)*(sw1_occupation-sw2_occupation_os))
        # sum(j,l)
        for (l, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(l,sw2_index) * ((nb_occupation-1)*(sw2_occupation_os-sw1_occupation)*sw2_occupation)
        # sum(i,m)
        for (m, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(sw1_index,m) * ((nb_occupation_os-1)*(sw1_occupation-sw2_occupation_os)*nb_occupation)
    if not sw1_up and sw2_up:
        # DOWN<->UP
        pass
        res += lam(sw1_index,sw2_index) * ((sw1_occupation-1)*(sw2_occupation_os-1)*(sw2_occupation-sw1_occupation_os))
        # sum(i,l)
        for (l, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(l,sw1_index) * ((nb_occupation-1)*(sw1_occupation_os-sw2_occupation)*sw1_occupation)
        # sum(j,l)
        for (l, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(l,sw2_index) * ((nb_occupation-1)*(sw2_occupation_os-1)*(sw2_occupation-sw1_occupation_os))
        # sum(j,m)
        for (m, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(sw2_index,m) * ((nb_occupation_os-1)*(sw2_occupation-sw1_occupation_os)*nb_occupation)
    if not sw1_up and not sw2_up:
        # DOWN<->DOWN
        pass
        res += lam(sw2_index,sw1_index) * ((sw2_occupation-1)*(sw1_occupation_os-sw2_occupation_os)*sw1_occupation)
        res += lam(sw1_index,sw2_index) * ((sw1_occupation-1)*(sw2_occupation_os-sw1_occupation_os)*sw2_occupation)
        # sum(i,l)
        for (l, nb_occupation, nb_occupation_os) in sw1_neighbors_index_occupation_tuples:
            res += lam(l,sw1_index) * ((nb_occupation-1)*(sw1_occupation_os-sw2_occupation_os)*sw1_occupation)
        # sum(j,l)
        for (l, nb_occupation, nb_occupation_os) in sw2_neighbors_index_occupation_tuples:
            res += lam(l,sw2_index) * ((nb_occupation-1)*(sw2_occupation_os-sw1_occupation_os)*sw2_occupation)
    return res


def ClCHm_flipping(flipping_up: bool, flipping_index: int, flipping_occupation_before_flip: int, flipping_occupation_before_flip_os: int, lam: Callable[[int, int], np.complex128],  flipping_neighbors_index_occupation_tuples: List[Tuple[int,int,int]]) -> np.complex128:
    res:np.complex128 = np.complex128(0)
    if flipping_up:
        # flipping UP 0<->1
        pass
        # sum(i,m)
        for (m, nb_occupation, nb_occupation_os) in flipping_neighbors_index_occupation_tuples:
            res += lam(flipping_index,m) * ((1-(2*flipping_occupation_before_flip))*nb_occupation)
        # sum(i,l)
        for (l, nb_occupation, nb_occupation_os) in flipping_neighbors_index_occupation_tuples:
            res += lam(l,flipping_index) * ((1-(2*flipping_occupation_before_flip))*(nb_occupation-1))
    if not flipping_up:
        # flipping DOWN 0<->1
        pass
    return res


def DlDHm_flipping(flipping_up: bool, flipping_index: int, flipping_occupation_before_flip: int, flipping_occupation_before_flip_os: int, lam: Callable[[int, int], np.complex128],  flipping_neighbors_index_occupation_tuples: List[Tuple[int,int,int]]) -> np.complex128:
    res:np.complex128 = np.complex128(0)
    if flipping_up:
        # flipping UP 0<->1
        pass
    if not flipping_up:
        # flipping DOWN 0<->1
        pass
        # sum(i,m)
        for (m, nb_occupation, nb_occupation_os) in flipping_neighbors_index_occupation_tuples:
            res += lam(flipping_index,m) * ((1-(2*flipping_occupation_before_flip_os))*nb_occupation_os)
        # sum(i,l)
        for (l, nb_occupation, nb_occupation_os) in flipping_neighbors_index_occupation_tuples:
            res += lam(l,flipping_index) * ((1-(2*flipping_occupation_before_flip_os))*(nb_occupation_os-1))
    return res


def ClCmCHlCHmDlDHm_flipping(flipping_up: bool, flipping_index: int, flipping_occupation_before_flip: int, flipping_occupation_before_flip_os: int, lam: Callable[[int, int], np.complex128],  flipping_neighbors_index_occupation_tuples: List[Tuple[int,int,int]]) -> np.complex128:
    res:np.complex128 = np.complex128(0)
    if flipping_up:
        # flipping UP 0<->1
        pass
        # sum(i,m)
        for (m, nb_occupation, nb_occupation_os) in flipping_neighbors_index_occupation_tuples:
            res += lam(flipping_index,m) * ((1-(2*flipping_occupation_before_flip))*(nb_occupation-1)*(flipping_occupation_before_flip_os-1)*nb_occupation_os)
        # sum(i,l)
        for (l, nb_occupation, nb_occupation_os) in flipping_neighbors_index_occupation_tuples:
            res += lam(l,flipping_index) * ((1-(2*flipping_occupation_before_flip))*(nb_occupation-1)*(nb_occupation_os-1)*flipping_occupation_before_flip_os)
    if not flipping_up:
        # flipping DOWN 0<->1
        pass
        # sum(i,m)
        for (m, nb_occupation, nb_occupation_os) in flipping_neighbors_index_occupation_tuples:
            res += lam(flipping_index,m) * ((1-(2*flipping_occupation_before_flip_os))*(flipping_occupation_before_flip-1)*(nb_occupation-1)*nb_occupation_os)
        # sum(i,l)
        for (l, nb_occupation, nb_occupation_os) in flipping_neighbors_index_occupation_tuples:
            res += lam(l,flipping_index) * ((1-(2*flipping_occupation_before_flip_os))*(flipping_occupation_before_flip-1)*(nb_occupation-1)*(nb_occupation_os-1))
    return res


def ClCHmDlDmDHlDHm_flipping(flipping_up: bool, flipping_index: int, flipping_occupation_before_flip: int, flipping_occupation_before_flip_os: int, lam: Callable[[int, int], np.complex128],  flipping_neighbors_index_occupation_tuples: List[Tuple[int,int,int]]) -> np.complex128:
    res:np.complex128 = np.complex128(0)
    if flipping_up:
        # flipping UP 0<->1
        pass
        # sum(i,m)
        for (m, nb_occupation, nb_occupation_os) in flipping_neighbors_index_occupation_tuples:
            res += lam(flipping_index,m) * ((1-(2*flipping_occupation_before_flip))*(flipping_occupation_before_flip_os-1)*(nb_occupation_os-1)*nb_occupation)
        # sum(i,l)
        for (l, nb_occupation, nb_occupation_os) in flipping_neighbors_index_occupation_tuples:
            res += lam(l,flipping_index) * ((1-(2*flipping_occupation_before_flip))*(nb_occupation-1)*(flipping_occupation_before_flip_os-1)*(nb_occupation_os-1))
    if not flipping_up:
        # flipping DOWN 0<->1
        pass
        # sum(i,m)
        for (m, nb_occupation, nb_occupation_os) in flipping_neighbors_index_occupation_tuples:
            res += lam(flipping_index,m) * ((1-(2*flipping_occupation_before_flip_os))*(flipping_occupation_before_flip-1)*(nb_occupation_os-1)*nb_occupation)
        # sum(i,l)
        for (l, nb_occupation, nb_occupation_os) in flipping_neighbors_index_occupation_tuples:
            res += lam(l,flipping_index) * ((1-(2*flipping_occupation_before_flip_os))*(nb_occupation-1)*(nb_occupation_os-1)*flipping_occupation_before_flip)
    return res


def ClCHlDlDHm_flipping(flipping_up: bool, flipping_index: int, flipping_occupation_before_flip: int, flipping_occupation_before_flip_os: int, lam: Callable[[int, int], np.complex128],  flipping_neighbors_index_occupation_tuples: List[Tuple[int,int,int]]) -> np.complex128:
    res:np.complex128 = np.complex128(0)
    if flipping_up:
        # flipping UP 0<->1
        pass
        # sum(i,m)
        for (m, nb_occupation, nb_occupation_os) in flipping_neighbors_index_occupation_tuples:
            res += lam(flipping_index,m) * (((2*flipping_occupation_before_flip)-1)*(flipping_occupation_before_flip_os-1)*nb_occupation_os)
    if not flipping_up:
        # flipping DOWN 0<->1
        pass
        # sum(i,m)
        for (m, nb_occupation, nb_occupation_os) in flipping_neighbors_index_occupation_tuples:
            res += lam(flipping_index,m) * (((2*flipping_occupation_before_flip_os)-1)*(flipping_occupation_before_flip-1)*nb_occupation_os)
        # sum(i,l)
        for (l, nb_occupation, nb_occupation_os) in flipping_neighbors_index_occupation_tuples:
            res += lam(l,flipping_index) * (((2*flipping_occupation_before_flip_os)-1)*(nb_occupation-1)*(nb_occupation_os-1))
    return res


def CmCHmDlDHm_flipping(flipping_up: bool, flipping_index: int, flipping_occupation_before_flip: int, flipping_occupation_before_flip_os: int, lam: Callable[[int, int], np.complex128],  flipping_neighbors_index_occupation_tuples: List[Tuple[int,int,int]]) -> np.complex128:
    res:np.complex128 = np.complex128(0)
    if flipping_up:
        # flipping UP 0<->1
        pass
        # sum(i,l)
        for (l, nb_occupation, nb_occupation_os) in flipping_neighbors_index_occupation_tuples:
            res += lam(l,flipping_index) * (((2*flipping_occupation_before_flip)-1)*(nb_occupation_os-1)*flipping_occupation_before_flip_os)
    if not flipping_up:
        # flipping DOWN 0<->1
        pass
        # sum(i,m)
        for (m, nb_occupation, nb_occupation_os) in flipping_neighbors_index_occupation_tuples:
            res += lam(flipping_index,m) * (((2*flipping_occupation_before_flip_os)-1)*(nb_occupation-1)*nb_occupation_os)
        # sum(i,l)
        for (l, nb_occupation, nb_occupation_os) in flipping_neighbors_index_occupation_tuples:
            res += lam(l,flipping_index) * (((2*flipping_occupation_before_flip_os)-1)*(flipping_occupation_before_flip-1)*(nb_occupation_os-1))
    return res


def ClCHmDlDHl_flipping(flipping_up: bool, flipping_index: int, flipping_occupation_before_flip: int, flipping_occupation_before_flip_os: int, lam: Callable[[int, int], np.complex128],  flipping_neighbors_index_occupation_tuples: List[Tuple[int,int,int]]) -> np.complex128:
    res:np.complex128 = np.complex128(0)
    if flipping_up:
        # flipping UP 0<->1
        pass
        # sum(i,m)
        for (m, nb_occupation, nb_occupation_os) in flipping_neighbors_index_occupation_tuples:
            res += lam(flipping_index,m) * (((2*flipping_occupation_before_flip)-1)*(flipping_occupation_before_flip_os-1)*nb_occupation)
        # sum(i,l)
        for (l, nb_occupation, nb_occupation_os) in flipping_neighbors_index_occupation_tuples:
            res += lam(l,flipping_index) * (((2*flipping_occupation_before_flip)-1)*(nb_occupation-1)*(nb_occupation_os-1))
    if not flipping_up:
        # flipping DOWN 0<->1
        pass
        # sum(i,m)
        for (m, nb_occupation, nb_occupation_os) in flipping_neighbors_index_occupation_tuples:
            res += lam(flipping_index,m) * (((2*flipping_occupation_before_flip_os)-1)*(flipping_occupation_before_flip-1)*nb_occupation)
    return res


def ClCHmDmDHm_flipping(flipping_up: bool, flipping_index: int, flipping_occupation_before_flip: int, flipping_occupation_before_flip_os: int, lam: Callable[[int, int], np.complex128],  flipping_neighbors_index_occupation_tuples: List[Tuple[int,int,int]]) -> np.complex128:
    res:np.complex128 = np.complex128(0)
    if flipping_up:
        # flipping UP 0<->1
        pass
        # sum(i,m)
        for (m, nb_occupation, nb_occupation_os) in flipping_neighbors_index_occupation_tuples:
            res += lam(flipping_index,m) * (((2*flipping_occupation_before_flip)-1)*(nb_occupation_os-1)*nb_occupation)
        # sum(i,l)
        for (l, nb_occupation, nb_occupation_os) in flipping_neighbors_index_occupation_tuples:
            res += lam(l,flipping_index) * (((2*flipping_occupation_before_flip)-1)*(nb_occupation-1)*(flipping_occupation_before_flip_os-1))
    if not flipping_up:
        # flipping DOWN 0<->1
        pass
        # sum(i,l)
        for (l, nb_occupation, nb_occupation_os) in flipping_neighbors_index_occupation_tuples:
            res += lam(l,flipping_index) * (((2*flipping_occupation_before_flip_os)-1)*(nb_occupation-1)*flipping_occupation_before_flip)
    return res


