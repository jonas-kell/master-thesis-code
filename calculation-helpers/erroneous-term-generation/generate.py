from typing import List
import subprocess


def runCommandWithInput(command, input_string):
    with subprocess.Popen(
        command,
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
    ) as process:

        stdout, stderr = process.communicate(input_string)

        if process.returncode != 0:
            return f"Error: {stderr}"

    return stdout


def execEspressoOnInput(inputStr: str):
    return runCommandWithInput(["./program-generation/bin/espresso"], inputStr)


def xor(a, b):
    return bool(a) ^ bool(b)


def genEspressoInput(logicCallback, restrict=True):
    result = ""

    result += ".i 4\n"  # inputs
    result += ".o 1\n"  # outputs
    result += f".p {2**4}\n"  # number of terms in the file following

    for Lc in range(2):
        for Mc in range(2):
            for Ld in range(2):
                for Md in range(2):
                    res = logicCallback(Lc, Mc, Ld, Md)
                    if restrict:
                        if res > 1:
                            raise Exception("Callback greater 1")
                        result += f"{Lc}{Mc}{Ld}{Md} {1 if res else 0}\n"
                    else:
                        result += f"{Lc}{Mc}{Ld}{Md} {res}\n"

    result += ".e"
    return result


def printDifference(logicCallback, logicCallback2):
    for Lc in range(2):
        for Mc in range(2):
            for Ld in range(2):
                for Md in range(2):
                    a = logicCallback(Lc, Mc, Ld, Md)
                    if a == True:
                        a = 1
                    if a == False:
                        a = 0

                    b = logicCallback2(Lc, Mc, Ld, Md)
                    if b == True:
                        b = 1
                    if b == False:
                        b = 0

                    if a != b:
                        print(f"{Lc}{Mc}{Ld}{Md}   {a} <-> {b}")


def checkOptimizations(inputMappings):
    for key, mappings in inputMappings.items():
        print("\n\n\n" + key)

        canEspresso = True
        try:
            test = genEspressoInput(mappings[1][0], canEspresso)
        except Exception:
            canEspresso = False
            test = genEspressoInput(mappings[1][0], False)  # CAN NO LONGER ERROR

        print(test)

        if canEspresso:
            print(execEspressoOnInput(test))

        for mapping in mappings[1]:
            if genEspressoInput(mapping, canEspresso) != test:
                print("Difference:")
                printDifference(mappings[1][0], mapping)

                raise Exception(f"Difference found at {key}")


def checkCoverage(inputMappings):
    for Lc in range(2):
        for Mc in range(2):
            for Ld in range(2):
                for Md in range(2):
                    print(f"{Lc}{Mc}{Ld}{Md}", end="")
                    for key, mappings in inputMappings.items():
                        mainMapping = mappings[1][0]
                        res = mainMapping(Lc, Mc, Ld, Md)
                        if res != 0 and res != False:
                            print(f"  {res} {key}", end="")
                    print("")


def checkSymmetry(inputMappings):
    for Lc in range(2):
        for Mc in range(2):
            for Ld in range(2):
                for Md in range(2):
                    for key, mappings in inputMappings.items():
                        mainMapping = mappings[1][0]
                        res = mainMapping(Lc, Mc, Ld, Md)
                        res2 = mainMapping(Ld, Md, Lc, Mc)

                        if res != res2:
                            raise Exception(f"{key} not symmetric at {Lc}{Mc}{Ld}{Md}")


FILENAME = "./v-components.py"


# This function marks the GENERATED FILE as not to be edited manually
def init_file():
    text = """# !! THIS FILE IS AUTOMATICALLY GENERATED.
# DO NOT EDIT. 
# SEE calculation-helpers/generate.py

from typing import List, Tuple
import numpy as np

"""
    with open(FILENAME, "w") as file:
        file.write(text)


def write_file(input: str):
    with open(FILENAME, "a") as file:
        file.write(input)


def indent(spaces: int):
    return "    " * spaces


def generateIfTree(
    initialIndent: int,
    checks: List[str],
    callbackForTop=lambda a, b: a + "pass\n",
    currentDepth: int = 0,
    currentTruthinesses: List[bool] = [],
) -> str:
    maxDepth = len(checks)

    if currentDepth == maxDepth:
        return callbackForTop(indent(initialIndent + currentDepth), currentTruthinesses)
    else:
        res = indent(initialIndent + currentDepth) + f"if {checks[currentDepth]}:\n"
        res += generateIfTree(
            initialIndent,
            checks,
            callbackForTop,
            currentDepth + 1,
            currentTruthinesses + [True],
        )
        res += indent(initialIndent + currentDepth) + "else:\n"
        res += generateIfTree(
            initialIndent,
            checks,
            callbackForTop,
            currentDepth + 1,
            currentTruthinesses + [False],
        )
        return res


def generateHelperFile(inputMappings):
    init_file()

    # normal V
    write_file(
        "def v(U: float, t: float, epsl: float, occ_l_up: int, occ_l_down: int,neighbors_eps_occupation_tuples: List[Tuple[float, int, int]],) -> np.complex128:\n"
    )
    write_file(indent(1) + "res: np.complex128 = np.complex128(0)\n")
    write_file(
        indent(1)
        + "for (epsm, occ_m_up, occ_m_down,) in neighbors_eps_occupation_tuples:\n"
    )

    def endCallback(lineStart: str, currentTruthinesses: List[bool]):
        Lc, Ld, Mc, Md = currentTruthinesses

        res = ""
        res += lineStart + f"# Lc:{Lc}, Mc:{Mc}, Ld:{Ld}, Md:{Md}" + "\n"
        res += lineStart + "res += 0 "
        for meta, mappings in inputMappings.values():
            factor, numpyStuff = meta
            mult = factor * mappings[0](Lc, Mc, Ld, Md)
            if mult != 0:
                res += (
                    "+ " + str(mult) + " * " + numpyStuff
                )  #! doesn't do more than 2 letters, as not necessary
        res += "\n"
        return res

    write_file(
        generateIfTree(
            2, ["occ_l_up", "occ_l_down", "occ_m_up", "occ_m_down"], endCallback
        )
    )

    write_file(indent(1) + "return res\n\n\n")


mappingsDict = {
    "16CF": (
        (
            16,
            "(( ( ((U + epsl)-(U + epsm)) * np.sin( ((U + epsl)+(U + epsm)) * t ) + ((U + epsl)+(U + epsm)) * np.sin( ((U + epsm)-(U + epsl)) * t ) ) /(2 *((U + epsm)**2 - (U + epsl)**2)) )-( ( ((U + epsl)-(epsm)) * np.sin( ((U + epsl)+(epsm)) * t ) + ((U + epsl)+(epsm)) * np.sin( ((epsm)-(U + epsl)) * t ) ) /(2 *((epsm)**2 - (U + epsl)**2)) )-( ( ((epsl)-(U + epsm)) * np.sin( ((epsl)+(U + epsm)) * t ) + ((epsl)+(U + epsm)) * np.sin( ((U + epsm)-(epsl)) * t ) ) /(2 *((U + epsm)**2 - (epsl)**2)) )+( ( ((epsl)-(epsm)) * np.sin( ((epsl)+(epsm)) * t ) + ((epsl)+(epsm)) * np.sin( ((epsm)-(epsl)) * t ) ) /(2 *((epsm)**2 - (epsl)**2)) ))",
        ),
        # "C": "(np.sin((U + epsm) * t) - np.sin(epsm * t))",
        # "F": "(np.sin((U + epsl) * t) - np.sin(epsl * t))",
        [
            lambda Lc, Mc, Ld, Md: Lc * Ld * Md * (1 - Mc) + Ld * Lc * Mc * (1 - Md),
            lambda Lc, Mc, Ld, Md: Lc * Ld * (Md + Mc - (2 * Mc * Md)),
            lambda Lc, Mc, Ld, Md: Lc and Ld and xor(Md, Mc),
        ],
    ),
    "2iAE": (
        (
            2j,
            "(( ( np.exp((-1j * epsm) * t) * ( (-1j * epsm) * np.sin((epsl) * t) - (epsl) * np.cos((-1j * epsm) * t) ) + (epsl) ) / ((-1j * epsm)**2 + (epsl)**2) ))",
        ),
        # "A": "np.exp(- 1j * epsm * t)",
        # "E": "np.sin(epsl * t)",
        [
            lambda Lc, Mc, Ld, Md: Lc
            - (Lc * (1 - Mc) * Ld)
            + Ld
            - (Ld * (1 - Md) * Lc),
            # lambda Lc, Mc, Ld, Md: Lc != Mc or Mc and Ld or Md and Ld, # doesn't capture 1111 being 2
        ],
    ),
    "2iBD": (
        (
            2j,
            "(( ( np.exp((1j * epsl) * t) * ( (1j * epsl) * np.sin((epsm) * t) - (epsm) * np.cos((1j * epsl) * t) ) + (epsm) ) / ((1j * epsl)**2 + (epsm)**2) ))",
        ),
        # "B": "np.sin(epsm * t)",
        # "D": "np.exp(1j * epsl * t)",
        [
            lambda Lc, Mc, Ld, Md: Lc * (1 - Mc) * Md + Ld * (1 - Md) * Mc,
        ],
    ),
    "8BF": (
        (
            8,
            "(( ( ((U + epsl)-(epsm)) * np.sin( ((U + epsl)+(epsm)) * t ) + ((U + epsl)+(epsm)) * np.sin( ((epsm)-(U + epsl)) * t ) ) /(2 *((epsm)**2 - (U + epsl)**2)) )-( ( ((epsl)-(epsm)) * np.sin( ((epsl)+(epsm)) * t ) + ((epsl)+(epsm)) * np.sin( ((epsm)-(epsl)) * t ) ) /(2 *((epsm)**2 - (epsl)**2)) ))",
        ),
        # "B": "np.sin(epsm * t)",
        # "F": "(np.sin((U + epsl) * t) - np.sin(epsl * t))",
        [
            lambda Lc, Mc, Ld, Md: Lc * Ld * (1 - Mc - Md) + Ld * Lc * (1 - Md - Mc),
        ],
    ),
    "8CE": (
        (
            8,
            "(( ( ((U + epsm)-(epsl)) * np.sin( ((U + epsm)+(epsl)) * t ) + ((U + epsm)+(epsl)) * np.sin( ((epsl)-(U + epsm)) * t ) ) /(2 *((epsl)**2 - (U + epsm)**2)) )-( ( ((epsm)-(epsl)) * np.sin( ((epsm)+(epsl)) * t ) + ((epsm)+(epsl)) * np.sin( ((epsl)-(epsm)) * t ) ) /(2 *((epsl)**2 - (epsm)**2)) ))",
        ),
        # "C": "(np.sin((U + epsm) * t) - np.sin(epsm * t))",
        # "E": "np.sin(epsl * t)",
        [
            lambda Lc, Mc, Ld, Md: Lc * Md * (1 - Mc) + Ld * Mc * (1 - Md),
        ],
    ),
    "4iAF": (
        (
            4j,
            "(( ( np.exp((-1j * epsm) * t) * ( (-1j * epsm) * np.sin((U + epsl) * t) - (U + epsl) * np.cos((-1j * epsm) * t) ) + (U + epsl) ) / ((-1j * epsm)**2 + (U + epsl)**2) )-( ( np.exp((-1j * epsm) * t) * ( (-1j * epsm) * np.sin((epsl) * t) - (epsl) * np.cos((-1j * epsm) * t) ) + (epsl) ) / ((-1j * epsm)**2 + (epsl)**2) ))",
        ),
        # "A": "np.exp(- 1j * epsm * t)",
        # "F": "(np.sin((U + epsl) * t) - np.sin(epsl * t))",
        [
            lambda Lc, Mc, Ld, Md: Lc * Ld + Ld * Lc,
            lambda Lc, Mc, Ld, Md: 2 * Lc * Ld,
        ],
    ),
    "4BE": (
        (
            4,
            "(( ( ((epsm)-(epsl)) * np.sin( ((epsm)+(epsl)) * t ) + ((epsm)+(epsl)) * np.sin( ((epsl)-(epsm)) * t ) ) /(2 *((epsl)**2 - (epsm)**2)) ))",
        ),
        # "B": "np.sin(epsm * t)",
        # "E": "np.sin(epsl * t)",
        [
            lambda Lc, Mc, Ld, Md: Lc * (1 - Mc - Md)
            + Lc * (1 - Mc) * Ld * Md
            + Ld * (1 - Md - Mc)
            + Ld * (1 - Md) * Lc * Mc,
        ],
    ),
    "AD": (
        (1, "(((1j * np.exp(1j * (epsl - epsm) * t)) - 1) / (epsm-epsl))"),
        # "A": "np.exp(- 1j * epsm * t)",
        # "D": "np.exp(1j * epsl * t)",
        [lambda Lc, Mc, Ld, Md: Lc * (1 - Mc) + Ld * (1 - Md)],
    ),
}


if __name__ == "__main__":
    checkSymmetry(mappingsDict)
    checkOptimizations(mappingsDict)
    print("Lc Mc Ld Md")
    checkCoverage(mappingsDict)

    generateHelperFile(mappingsDict)
