from typing import List
import subprocess


def runCommandWithInput(command, input_string):
    with subprocess.Popen(
        command,
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
    ) as process:

        stdout, stderr = process.communicate(input_string)

        if process.returncode != 0:
            return f"Error: {stderr}"

    return stdout


def execEspressoOnInput(inputStr: str):
    return runCommandWithInput(["./program-generation/bin/espresso"], inputStr)


def xor(a, b):
    return bool(a) ^ bool(b)


def genEspressoInput(logicCallback, restrict=True):
    result = ""

    result += ".i 4\n"  # inputs
    result += ".o 1\n"  # outputs
    result += f".p {2**4}\n"  # number of terms in the file following

    for Lc in range(2):
        for Mc in range(2):
            for Ld in range(2):
                for Md in range(2):
                    res = logicCallback(Lc, Mc, Ld, Md)
                    if restrict:
                        if res > 1:
                            raise Exception("Callback greater 1")
                        result += f"{Lc}{Mc}{Ld}{Md} {1 if res else 0}\n"
                    else:
                        result += f"{Lc}{Mc}{Ld}{Md} {res}\n"

    result += ".e"
    return result


def printDifference(logicCallback, logicCallback2):
    for Lc in range(2):
        for Mc in range(2):
            for Ld in range(2):
                for Md in range(2):
                    a = logicCallback(Lc, Mc, Ld, Md)
                    if a == True:
                        a = 1
                    if a == False:
                        a = 0

                    b = logicCallback2(Lc, Mc, Ld, Md)
                    if b == True:
                        b = 1
                    if b == False:
                        b = 0

                    if a != b:
                        print(f"{Lc}{Mc}{Ld}{Md}   {a} <-> {b}")


def checkOptimizations(inputMappings):
    for key, mappings in inputMappings.items():
        print("\n\n\n" + key)

        canEspresso = True
        try:
            test = genEspressoInput(mappings[1][0], canEspresso)
        except Exception:
            canEspresso = False
            test = genEspressoInput(mappings[1][0], False)  # CAN NO LONGER ERROR

        print(test)

        if canEspresso:
            print(execEspressoOnInput(test))

        for mapping in mappings[1]:
            if genEspressoInput(mapping, canEspresso) != test:
                print("Difference:")
                printDifference(mappings[1][0], mapping)

                raise Exception(f"Difference found at {key}")


def checkCoverage(inputMappings):
    for Lc in range(2):
        for Mc in range(2):
            for Ld in range(2):
                for Md in range(2):
                    print(f"{Lc}{Mc}{Ld}{Md}", end="")
                    for key, mappings in inputMappings.items():
                        mainMapping = mappings[1][0]
                        res = mainMapping(Lc, Mc, Ld, Md)
                        if res != 0 and res != False:
                            print(f"  {res} {key}", end="")
                    print("")


def checkSymmetry(inputMappings):
    for Lc in range(2):
        for Mc in range(2):
            for Ld in range(2):
                for Md in range(2):
                    for key, mappings in inputMappings.items():
                        mainMapping = mappings[1][0]
                        res = mainMapping(Lc, Mc, Ld, Md)
                        res2 = mainMapping(Ld, Md, Lc, Mc)

                        if res != res2:
                            raise Exception(f"{key} not symmetric at {Lc}{Mc}{Ld}{Md}")


FILENAME = "./../../computation-scripts/v-components.py"


# This function marks the GENERATED FILE as not to be edited manually
def init_file():
    text = """# !! THIS FILE IS AUTOMATICALLY GENERATED.
# DO NOT EDIT. 
# SEE calculation-helpers/generate.py

import numpy as np

"""
    with open(FILENAME, "w") as file:
        file.write(text)


def write_file(input: str):
    with open(FILENAME, "a") as file:
        file.write(input)


def indent(spaces: int):
    return "    " * spaces


def generateIfTree(
    initialIndent: int,
    checks: List[str],
    currentDepth: int = 0,
    currentTruthinesses: List[bool] = [],
) -> str:
    maxDepth = len(checks)

    if currentDepth == maxDepth:
        return (
            indent(initialIndent + currentDepth + 1)
            + "pass #"
            + str(currentTruthinesses)
            + "\n"
        )
    else:
        res = indent(initialIndent + currentDepth) + f"if {checks[currentDepth]}:\n"
        res += generateIfTree(
            initialIndent, checks, currentDepth + 1, currentTruthinesses + [True]
        )
        res += indent(initialIndent + currentDepth) + f"else:\n"
        res += generateIfTree(
            initialIndent, checks, currentDepth + 1, currentTruthinesses + [False]
        )
        return res


def generateHelperFile(inputMappings, inputCoefficientInfo):
    init_file()

    write_file(
        "def v(l: int, occ_l_up: int, occ_l_down: int,neighbors_index_occupation_tuples: List[Tuple[int, int, int]],) -> np.complex128:\n"
    )

    write_file(generateIfTree(1, ["a", "b", "c", "d"]))

    deep = 3
    write_file(indent(deep) + "res: np.complex128 = np.complex128(0)")
    write_file(
        indent(deep)
        + "for (m, occ_m_up, occ_m_down,) in flipping_neighbors_index_occupation_tuples:"
    )


mappingsDict = {
    "16CF": (
        (16, ["C", "F"]),
        [
            lambda Lc, Mc, Ld, Md: Lc * Ld * Md * (1 - Mc) + Ld * Lc * Mc * (1 - Md),
            lambda Lc, Mc, Ld, Md: Lc * Ld * (Md + Mc - (2 * Mc * Md)),
            lambda Lc, Mc, Ld, Md: Lc and Ld and xor(Md, Mc),
        ],
    ),
    "2iAE": (
        (2j, ["A", "E"]),
        [
            lambda Lc, Mc, Ld, Md: Lc
            - (Lc * (1 - Mc) * Ld)
            + Ld
            - (Ld * (1 - Md) * Lc),
            # lambda Lc, Mc, Ld, Md: Lc != Mc or Mc and Ld or Md and Ld, # doesn't capture 1111 being 2
        ],
    ),
    "2iBD": (
        (2j, ["B", "D"]),
        [
            lambda Lc, Mc, Ld, Md: Lc * (1 - Mc) * Md + Ld * (1 - Md) * Mc,
        ],
    ),
    "8BF": (
        (8, ["B", "F"]),
        [
            lambda Lc, Mc, Ld, Md: Lc * Ld * (1 - Mc - Md) + Ld * Lc * (1 - Md - Mc),
        ],
    ),
    "8CE": (
        (8, ["C", "E"]),
        [
            lambda Lc, Mc, Ld, Md: Lc * Md * (1 - Mc) + Ld * Mc * (1 - Md),
        ],
    ),
    "4iAF": (
        (4j, ["A", "F"]),
        [
            lambda Lc, Mc, Ld, Md: Lc * Ld + Ld * Lc,
            lambda Lc, Mc, Ld, Md: 2 * Lc * Ld,
        ],
    ),
    "4BE": (
        (4, ["B", "E"]),
        [
            lambda Lc, Mc, Ld, Md: Lc * (1 - Mc - Md)
            + Lc * (1 - Mc) * Ld * Md
            + Ld * (1 - Md - Mc)
            + Ld * (1 - Md) * Lc * Mc,
        ],
    ),
    "AD": ((1, ["A", "D"]), [lambda Lc, Mc, Ld, Md: Lc * (1 - Mc) + Ld * (1 - Md)]),
}

coefficientInfo = {
    "A": "np.exp(- 1j * epsm * t)",
    "B": "np.sin(epsm * t)",
    "C": "np.sin((U + epsm) * t) - np.sin(epsm * t)",
    "D": "np.exp(1j * epsl * t)",
    "E": "np.sin(epsl * t)",
    "F": "np.sin((U + epsl) * t) - np.sin(epsl * t)",
}


if __name__ == "__main__":
    checkSymmetry(mappingsDict)
    checkOptimizations(mappingsDict)
    print("Lc Mc Ld Md")
    checkCoverage(mappingsDict)

    generateHelperFile(mappingsDict, coefficientInfo)
